1.双端队列：即可以先入先出，也可以先入后出

2.优先队列：它遵循的不是先入先出，而是谁的优先级最高，谁先出队。
            它不属于线性数据结构的范畴，是基于二叉堆来实现的。

3.散列表：也叫哈希表，这种数据结构提供了键和值的映射关系。只要给出key就可以高效的查找到它匹配的value,时间复杂度接近于O（1）.

4.哈希函数：在java中常用的集合HashMap。每一个对象都有属于的自己的hashcode,这个hashcode是区分不同对象的重要标识。是一个整型变量。
            转换改成数组的下标，最简单的转换方式是按照数组长度进行取模运算。

                index=HashCode（Key）%Array.length

       实际上JDK中的哈希函数并没有直接采用取模运算，而是利用位运算的方式来优化性能。

二，散列表的读写操作

1，写操作（put）:就是在散列表中插入新的键值对。

由于数组的长度是有限的，当插入的Entry越来越多的时候，不同的key通过哈希函数获得的下标有可能是相同的，这种情况就叫哈希冲突。
解决哈希冲突有两种办法，一是开放寻址法，二是链表法。
一：其意思就是通过哈希函数获得其在数组中的下标，当其下标有了其他元素的时候，就向后移动一位，若后一位也有了元素，则继续向后移动一位。在java中ThreadLocal使用的就是开放寻址法。
二：链表法，被应用在java 的集合类HashMapz中，hashMap数组的每一个元素不仅是一个entry对象，还是一个链表的头节点。每一个entry对象通过next指针指向它的下一个entry节点。当新来的entry映射到与之冲突的数组位置时，只需要插入
到对应的链表中即可。


2，读操作（get）
根据对应的key获取到对应的vaule

3.扩容（resize）

散列表是基于数组实现的，所以散列表也要涉及到扩容的问题。

影响其扩容的因素有两个：

capacity:即hashmap的当前长度。
LoadFactor：即hashmap的负载因子，默认值是0.75f

衡量hashmap需要进行扩容的条件如下：

                HashMap.size>=Capacity*LoadFactor



        扩容不仅是简单地把散列表的长队扩大，而是经历了以下两个步骤：
        1.扩容：创建一个新的Entry空数组，长度是原数组的2倍。
        2.重新Hash,便利原Entry数组，把所有的Entry重新Hash到新数组中。

        小结：

   1,什么是数组
   数组是由有限个相同类型的变量所组成的集合。
   2，什么是链表
   链表是一种链式数据结构，由若干节点组成，每个节点包含指向下一节点的指针。
   链表的物理存储方式是随机存储，访问方式是顺序访问。
   3，什么是栈
   是一种线性逻辑结构，可以是数组实现，也可以是链表实现，栈是先入后出！！
   4，什么是队列
   也是一种线性逻辑结构，队列包含出队和入队，如MeassageQueue 消息队列， 先入先出！！！
   5，什么是散列表
   散列表也叫哈希表，也就是key value的集合，通过哈希函数实现key和数组小标的转换，通过开放寻址法和链表法解决哈希冲突。
